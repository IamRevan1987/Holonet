import json
import re
import psutil
import os
from dataclasses import dataclass, field
from pathlib import Path
from typing import List, Dict, Tuple
import tiktoken

from langchain_ollama import ChatOllama
from pydantic import BaseModel, Field
from langchain_text_splitters import MarkdownHeaderTextSplitter
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.tree import Tree as RichTree

BASE_DIR = Path.home() / "docker/APIinterface/Holonet"
KB_DIR = BASE_DIR / "Knowledgebase_Alpha"
KB_FILE = KB_DIR / "holonet_resources.json"
MAX_NODES_DISPLAY = 5
MAX_CONTEXT_TOKENS = 4500
MAX_RETRIEVAL_NODES = 4
MAX_SUMMARY_TOKENS = 3000


console = Console()
KB_DIR.mkdir(parents=True, exist_ok=True)

model = ChatOllama(
    model="gemma3:1b",
    temperature=0,
    num_ctx=6000,
    seed=24,
    num_predict=1024,
    num_thread=12,
    num_gpu=1,
    repeat_penalty=1.1,
    top_k=40,
    top_p=0.9,
    mirostat=0,
    timeout=60,

)


tokenizer = tiktoken.get_encoding("cl100k_base")

def count_tokens(text: str) -> int:
    return len(tokenizer.encode(text))

def trim_to_token_limit(text: str, max_tokens: int) -> str:
    tokens = tokenizer.encode(text)
    if len(tokens) <= max_tokens:
        return text
    return tokenizer.decode(tokens[:max_tokens])

@dataclass
class TreeNode:
    title: str
    node_id: str
    content: str
    summary: str = ""
    nodes: List["TreeNode"] = field(default_factory=list)

    def to_dict(self, include_content: bool = True) -> dict:
        result = {"title": self.title, "node_id": self.node_id, "summary": self.summary}
        if include_content:
            result["content"] = self.content
        if self.nodes:
            result["nodes"] = [n.to_dict(include_content) for n in self.nodes]
        return result

    def node_count(self) -> int:
        return 1 + sum(c.node_count() for c in self.nodes)

class TreeSearchResult(BaseModel):
    thinking: str = Field(description="Reasoning about which nodes are relevant")
    node_list: List[str] = Field(description="List of relevant node IDs")

search_model = model.with_structured_output(TreeSearchResult)

SUMMARY_PROMPT = """Extract core technical specifications from this section. 
Identify: Networking protocols such as OSI layers, Security controls, CLI syntax (PowerShell/Bash/Cisco iOS), NIST,
Hardware IDs, SQL schemas, or UX heuristics.
Maintain technical nomenclature, process/troubleshooting order and exact command flags.
Section: {title}

{content}"""

TREE_SEARCH_PROMPT = """You are a Senior Systems Architect. Analyze the document tree to locate 
specific technical context for the query. 
Route based on domain: Networking, OS, Security, or Dev.
Select nodes representing the highest granular technical detail.
Question: {query}

Document tree structure:
{tree_index}"""

ANSWER_PROMPT = """Act as a Tier 3 Engineer. Answer using the context provided following IT SOP standards.
1. Lead with CLI commands or configuration snippets if available.
2. Specify OS/Hardware dependencies and relevant standards.
3. If the context is insufficient, state:
'It appears there was some difficulty obtaining the content you requested.'
Question: {query}

Context:
{context}

Answer:"""

def _has_meaningful_content(text: str, min_length: int = 40) -> bool:
    if not text:
        return False
    stripped = re.sub(r"^#+\s+.*$", "", text, flags=re.MULTILINE)
    stripped = stripped.strip()
    return len(stripped) >= min_length

def build_tree(markdown: str) -> TreeNode:
    splitter = MarkdownHeaderTextSplitter(
        headers_to_split_on=[("#", "title"), ("##", "section"), ("###", "subsection")],
        strip_headers=False,
    )
    sections = splitter.split_text(markdown)
    root = TreeNode(title="Holonet Root", node_id="0000", content="")
    counter = 1
    stack: List[Tuple[int, TreeNode]] = [(0, root)]
    levels = {"title": 1, "section": 2, "subsection": 3}

    for section in sections:
        level, title = 0, "General"
        for key, val in levels.items():
            if key in section.metadata:
                level, title = val, section.metadata[key]
        if level == 0:
            root.content += section.page_content
            continue
        node = TreeNode(title=title, node_id=f"{counter:04d}", content=section.page_content)
        counter += 1
        while len(stack) > 1 and stack[-1][0] >= level:
            stack.pop()
        stack[-1][1].nodes.append(node)
        stack.append((level, node))
    return root

def summarize_tree(node: TreeNode):
    for child in node.nodes:
        summarize_tree(child)
    has_content = _has_meaningful_content(node.content)
    has_child_summaries = any(c.summary for c in node.nodes)
    if not has_content and not has_child_summaries:
        return
    if has_child_summaries:
        children_text = "\n".join(
            f"- {c.title}: {c.summary}" for c in node.nodes if c.summary
        )
        text = (
            f"{node.content}\n\nChild Sections:\n{children_text}"
            if has_content else children_text
        )
    else:
        text = node.content
    trimmed = trim_to_token_limit(text, MAX_SUMMARY_TOKENS)
    node.summary = model.invoke(
        SUMMARY_PROMPT.format(title=node.title, content=trimmed)
    ).content.strip()

def create_node_map(node: TreeNode) -> Dict[str, TreeNode]:
    m = {node.node_id: node}
    for c in node.nodes:
        m.update(create_node_map(c))
    return m

def build_context(node_map: Dict[str, TreeNode], node_ids: List[str]) -> str:
    total_tokens = 0
    context_parts = []
    for nid in node_ids[:MAX_RETRIEVAL_NODES]:
        if nid not in node_map:
            continue
        content = node_map[nid].content
        tokens = count_tokens(content)
        if total_tokens + tokens > MAX_CONTEXT_TOKENS:
            remaining = MAX_CONTEXT_TOKENS - total_tokens
            if remaining <= 0:
                break
            content = trim_to_token_limit(content, remaining)
            context_parts.append(content)
            break
        context_parts.append(content)
        total_tokens += tokens
    return "\n\n".join(context_parts)

def retrieve_and_answer(tree: TreeNode, query: str):
    process = psutil.Process(os.getpid())
    mem_mb = process.memory_info().rss / (1024 * 1024)
    if mem_mb > 10000:
        raise MemoryError("Process exceeded 10GB RAM safety threshold")

    node_map = create_node_map(tree)
    tree_index = json.dumps(tree.to_dict(False))
    search_res = search_model.invoke(
        TREE_SEARCH_PROMPT.format(query=query, tree_index=tree_index)
    )
    context = build_context(node_map, search_res.node_list)
    answer = model.invoke(
        ANSWER_PROMPT.format(query=query, context=context)
    ).content.strip()
    return answer, search_res.node_list, search_res.thinking

if __name__ == "__main__":
    console.print(Panel("[bold cyan]HOLONET VECTORLESS RAG[/bold cyan]"))
    if KB_FILE.exists():
        with open(KB_FILE) as f:
            def load(d):
                n = TreeNode(d["title"], d["node_id"], d.get("content", ""), d.get("summary", ""))
                n.nodes = [load(c) for c in d.get("nodes", [])]
                return n
            tree = load(json.load(f))
    else:
        exit()

    node_map = create_node_map(tree)

    sample = {
        nid: {
            "title": node.title,
            "summary": (node.summary[:100] + "...") if len(node.summary) > 100 else node.summary,
            "content_length": len(node.content),
            "children": len(node.nodes),
        }
        for nid, node in list(node_map.items())[:MAX_NODES_DISPLAY]
    }

    console.print(Syntax(json.dumps(sample, indent=2), "json", theme="one-dark"))

    queries = [
    "What are the recommended NIST protocols for securing CLI access?",
    "List the mandatory access control requirements for administrator accounts.",
    "What are good methods for consolidating lines of python code?",
    "Compare the logging requirements for success vs failed login attempts.",
    "Should I open the PSU to clean out dust on the fans?"
    "What are the 4 methods of threat modeling?"
    "Unknown query test: What is the weather in Tatooine?" # Verification for grounding
]

    for query in queries:
        answer, node_ids, thinking = retrieve_and_answer(tree, query)
        console.print(Panel(thinking, title="Architect Reasoning", border_style="yellow"))
        console.print(answer)

